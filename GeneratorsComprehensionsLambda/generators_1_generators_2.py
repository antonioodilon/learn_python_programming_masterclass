import sys


def generator_range_2(n: int):
    print("generator_range_2 starts")
    start = 0
    while start < n:
        print("generator_range_2 is returning", start)
        yield start
        start += 1


# _ = input("line 47")
small_range_2 = generator_range_2(5)  # It's a bad idea to assign a generator
# to a variable, as we've done here
_ = input("line 16")

# next() returns the next item from an iterator. Since small_range_2 is an
# iterable, then it returned the first item generated by generator_range_2.
# The following item will be the second item, which will be returned when
# the values start to be appended in the for loop below. In fact, the first
# item to be appended to small_list will be the second item from small_range_2
print(next(small_range_2))
print("small_range is {} bytes".format(sys.getsizeof(small_range_2)))
small_list = []

_ = input("line 27")
# Each time we press Enter when the input line gets called, for calls next
# to get the next value
for value in small_range_2:
    _ = input("line 31 - inside loop")
    small_list.append(value)

print("small_list is {} bytes".format(sys.getsizeof(small_list)))
print(small_range_2)
print(small_list)

print("-" * 60)

print("Line 40 - We won't loop again:")
for i in small_range_2:
    print("i is now", i)
# We don't loop again here because we've stored generator_range_2() inside
# the variable small_range_2. In order to loop again we need to call the
# function once more, as we are doing below.

print("-" * 60)

# Notice that despite next() being called on line 23 above, the loop starts
# for 0 instead of one, since now we are calling the function directly, and
# not the variable.
print("Line 52 - Now we are going to loop again:")
for j in generator_range_2(5):
    print("j is now", j)